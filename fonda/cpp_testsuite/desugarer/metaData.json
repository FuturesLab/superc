[
  {
    "typechecker/configurable/PASS_basic_type.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/configurable/PASS_basic_pointer_array.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/configurable/PASS_basic_typedef.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/configurable/PASS_basic_pointers.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/configurable/declList.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/configurable/PASS_impossibleTypedef.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/configurable/PASS_impossibleTypedef.c: In function \u2018main\u2019:\ntypechecker/configurable/PASS_impossibleTypedef.c:7:3: error: unknown type name \u2018a\u2019\n   a x;\n   ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/configurable/PASS_basic_decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/configurable/PASS_basic_init.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/configurable/PASS_mutuallyExclusiveTypedefs.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/configurable/PASS_impossibleTypedef2.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/configurable/PASS_impossibleTypedef2.c: In function \u2018main\u2019:\ntypechecker/configurable/PASS_impossibleTypedef2.c:8:3: error: unknown type name \u2018a\u2019\n   a x;\n   ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/configurable/PASS_basic_statement.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/functions/PASS_multipleConfigs.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/functions/PASS_configParam.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/functions/PASS_conditionalParams.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/functions/PASS_basicFunctions.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/functions/PASS_valid_type_function.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/functions/PASS_void_abstract_functions.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/functions/PASS_void_abstract_functions.c:2:1: error: \u2018void\u2019 must be the only parameter\n void *fwo(void, void);\n ^~~~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/functions/function_pointer.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/functions/PASS_typedefParams.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/functions/PASS_invalid_type_function.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/functions/PASS_invalid_type_function.c:2:12: warning: variable \u2018y\u2019 declared \u2018inline\u2019\n inline int y;\n            ^\ntypechecker/functions/PASS_invalid_type_function.c:1:6: error: storage size of \u2018x\u2019 isn\u2019t known\n void x;\n      ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/functions/PASS_abstractParam.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/test_struct.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_partial_redeclaration1.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/scope_partial_declaration2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/undeclared_identifer.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/examples/undeclared_identifer.c: In function \u2018main\u2019:\ntypechecker/examples/undeclared_identifer.c:2:3: error: unknown type name \u2018a\u2019\n   a x;\n   ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_partial_redeclaration2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_global_redef_invalid.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/malloc_const_void_ptr.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_valid_signed_unsigned.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/volatile_abstract_declarator.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_valid_long.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/typedef_stdio.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_missing_types_valid_qualifiers.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"typechecker/examples/PASS_missing_types_valid_qualifiers.c: In function \u2018main\u2019:\ntypechecker/examples/PASS_missing_types_valid_qualifiers.c:3:15: warning: type defaults to \u2018int\u2019 in declaration of \u2018a\u2019 [-Wimplicit-int]\n  static const a;\n               ^\ntypechecker/examples/PASS_missing_types_valid_qualifiers.c:4:15: warning: type defaults to \u2018int\u2019 in declaration of \u2018b\u2019 [-Wimplicit-int]\n  extern const b;\n               ^\ntypechecker/examples/PASS_missing_types_valid_qualifiers.c:5:13: warning: type defaults to \u2018int\u2019 in declaration of \u2018c\u2019 [-Wimplicit-int]\n  auto const c;\n             ^\ntypechecker/examples/PASS_missing_types_valid_qualifiers.c:6:16: warning: type defaults to \u2018int\u2019 in declaration of \u2018d\u2019 [-Wimplicit-int]\n  auto volatile d;\n                ^\ntypechecker/examples/PASS_missing_types_valid_qualifiers.c:7:17: warning: type defaults to \u2018int\u2019 in declaration of \u2018e\u2019 [-Wimplicit-int]\n  const volatile e;\n                 ^\ntypechecker/examples/PASS_missing_types_valid_qualifiers.c:8:18: warning: type defaults to \u2018int\u2019 in declaration of \u2018f\u2019 [-Wimplicit-int]\n  static volatile f;\n                  ^\ntypechecker/examples/PASS_missing_types_valid_qualifiers.c:9:18: warning: type defaults to \u2018int\u2019 in declaration of \u2018g\u2019 [-Wimplicit-int]\n  extern volatile g;\n                  ^\ntypechecker/examples/PASS_missing_types_valid_qualifiers.c:10:17: warning: type defaults to \u2018int\u2019 in declaration of \u2018h\u2019 [-Wimplicit-int]\n  register const h;\n                 ^\ntypechecker/examples/PASS_missing_types_valid_qualifiers.c:11:20: warning: type defaults to \u2018int\u2019 in declaration of \u2018i\u2019 [-Wimplicit-int]\n  register volatile i;\n                    ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_invalid_qualifiers.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/examples/PASS_invalid_qualifiers.c: In function \u2018main\u2019:\ntypechecker/examples/PASS_invalid_qualifiers.c:2:13: warning: variable \u2018a\u2019 declared \u2018inline\u2019\n  inline int a;\n             ^\ntypechecker/examples/PASS_invalid_qualifiers.c:3:14: warning: variable \u2018b\u2019 declared \u2018inline\u2019\n  inline long b;\n              ^\ntypechecker/examples/PASS_invalid_qualifiers.c:4:2: error: multiple storage classes in declaration specifiers\n  static extern int c;\n  ^~~~~~\ntypechecker/examples/PASS_invalid_qualifiers.c:5:3: error: multiple storage classes in declaration specifiers\n   static auto int d;\n   ^~~~~~\ntypechecker/examples/PASS_invalid_qualifiers.c:6:2: error: multiple storage classes in declaration specifiers\n  auto extern int e;\n  ^~~~\ntypechecker/examples/PASS_invalid_qualifiers.c:7:2: error: multiple storage classes in declaration specifiers\n  auto register int f;\n  ^~~~\ntypechecker/examples/PASS_invalid_qualifiers.c:8:2: error: multiple storage classes in declaration specifiers\n  static register int g;\n  ^~~~~~\ntypechecker/examples/PASS_invalid_qualifiers.c:9:2: error: multiple storage classes in declaration specifiers\n  register extern int h;\n  ^~~~~~~~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_staticint.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_invalid_signed_unsigned.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/examples/PASS_invalid_signed_unsigned.c: In function \u2018main\u2019:\ntypechecker/examples/PASS_invalid_signed_unsigned.c:2:9: error: both \u2018signed\u2019 and \u2018unsigned\u2019 in declaration specifiers\n  signed unsigned int a;\n         ^~~~~~~~\ntypechecker/examples/PASS_invalid_signed_unsigned.c:3:9: error: both \u2018signed\u2019 and \u2018float\u2019 in declaration specifiers\n  signed float b;\n         ^~~~~\ntypechecker/examples/PASS_invalid_signed_unsigned.c:4:11: error: both \u2018unsigned\u2019 and \u2018float\u2019 in declaration specifiers\n  unsigned float c;\n           ^~~~~\ntypechecker/examples/PASS_invalid_signed_unsigned.c:5:9: error: both \u2018signed\u2019 and \u2018double\u2019 in declaration specifiers\n  signed double d;\n         ^~~~~~\ntypechecker/examples/PASS_invalid_signed_unsigned.c:6:11: error: both \u2018unsigned\u2019 and \u2018double\u2019 in declaration specifiers\n  unsigned double e;\n           ^~~~~~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_no_redeclaration.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_noIdentifier.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/examples/PASS_noIdentifier.c:1:6: error: expected identifier or \u2018(\u2019 before \u2018;\u2019 token\n int *;\n      ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_invalid_duplicate_qualifiers.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/examples/PASS_invalid_duplicate_qualifiers.c: In function \u2018main\u2019:\ntypechecker/examples/PASS_invalid_duplicate_qualifiers.c:2:9: error: duplicate \u2018signed\u2019\n  signed signed int a;\n         ^~~~~~\ntypechecker/examples/PASS_invalid_duplicate_qualifiers.c:3:11: error: duplicate \u2018unsigned\u2019\n  unsigned unsigned unsigned int b;\n           ^~~~~~~~\ntypechecker/examples/PASS_invalid_duplicate_qualifiers.c:3:20: error: duplicate \u2018unsigned\u2019\n  unsigned unsigned unsigned int b;\n                    ^~~~~~~~\ntypechecker/examples/PASS_invalid_duplicate_qualifiers.c:4:2: error: duplicate \u2018static\u2019\n  static const static int c;\n  ^~~~~~\ntypechecker/examples/PASS_invalid_duplicate_qualifiers.c:5:2: error: duplicate \u2018auto\u2019\n  auto auto float d;\n  ^~~~\ntypechecker/examples/PASS_invalid_duplicate_qualifiers.c:6:2: error: duplicate \u2018extern\u2019\n  extern extern int e;\n  ^~~~~~\ntypechecker/examples/PASS_invalid_duplicate_qualifiers.c:7:2: error: duplicate \u2018register\u2019\n  register register int f;\n  ^~~~~~~~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_valid_qualifiers.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/scope_partial_declaration1.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_global_redef_valid.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/test_struct_prohibit_initializer.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/examples/test_struct_prohibit_initializer.c:2:9: error: expected \u2018:\u2019, \u2018,\u2019, \u2018;\u2019, \u2018}\u2019 or \u2018__attribute__\u2019 before \u2018=\u2019 token\n   int x = 1;\n         ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_valid_complex.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_seentypes.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/examples/PASS_seentypes.c: In function \u2018main\u2019:\ntypechecker/examples/PASS_seentypes.c:10:9: error: both \u2018short\u2019 and \u2018float\u2019 in declaration specifiers\n   float short q;\n         ^~~~~\ntypechecker/examples/PASS_seentypes.c:17:7: error: two or more data types in declaration specifiers\n   int float x;\n       ^~~~~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_valid_duplicate_qualifiers.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/PASS_invalid_long.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/examples/PASS_invalid_long.c: In function \u2018main\u2019:\ntypechecker/examples/PASS_invalid_long.c:2:12: error: both \u2018long long\u2019 and \u2018double\u2019 in declaration specifiers\n  long long double a;\n            ^~~~~~\ntypechecker/examples/PASS_invalid_long.c:3:7: error: both \u2018long\u2019 and \u2018float\u2019 in declaration specifiers\n  long float b;\n       ^~~~~\ntypechecker/examples/PASS_invalid_long.c:4:12: error: \u2018long long long\u2019 is too long for GCC\n  long long long c;\n            ^~~~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/typedef.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/examples/typedefname_with_qualifer.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/PASS_valid_typedef_ident.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/PASS_void_typedef.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/declarators/PASS_void_typedef.c:5:3: error: storage size of \u2018x\u2019 isn\u2019t known\n v x; //invalid\n   ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/PASS_invalid_typedefs.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/declarators/PASS_invalid_typedefs.c:1:1: error: multiple storage classes in declaration specifiers\n typedef extern int a;\n ^~~~~~~\ntypechecker/declarators/PASS_invalid_typedefs.c:2:1: error: multiple storage classes in declaration specifiers\n typedef register int b;\n ^~~~~~~\ntypechecker/declarators/PASS_invalid_typedefs.c:3:1: error: multiple storage classes in declaration specifiers\n static typedef int c;\n ^~~~~~\ntypechecker/declarators/PASS_invalid_typedefs.c:5:12: error: expected \u2018=\u2019, \u2018,\u2019, \u2018;\u2019, \u2018asm\u2019 or \u2018__attribute__\u2019 before \u2018d\u2019\n unsigned z d;\n            ^\ntypechecker/declarators/PASS_invalid_typedefs.c:6:10: error: expected \u2018=\u2019, \u2018,\u2019, \u2018;\u2019, \u2018asm\u2019 or \u2018__attribute__\u2019 before \u2018e\u2019\n signed z e;\n          ^\ntypechecker/declarators/PASS_invalid_typedefs.c:7:8: error: expected \u2018=\u2019, \u2018,\u2019, \u2018;\u2019, \u2018asm\u2019 or \u2018__attribute__\u2019 before \u2018f\u2019\n long z f;\n        ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/PASS_valid_typedef.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/PASS_valid_Array_Pointer.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"typechecker/declarators/PASS_valid_Array_Pointer.c:5:5: warning: array \u2018e\u2019 assumed to have one element\n int e[];\n     ^\ntypechecker/declarators/PASS_valid_Array_Pointer.c:9:7: warning: array \u2018i\u2019 assumed to have one element\n int **i[];\n       ^\ntypechecker/declarators/PASS_valid_Array_Pointer.c:12:6: warning: array \u2018l\u2019 assumed to have one element\n int (l[]);\n      ^\ntypechecker/declarators/PASS_valid_Array_Pointer.c:13:5: warning: array \u2018m\u2019 assumed to have one element\n int m[];\n     ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/PASS_valid_decl_quals.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/PASS_valid_array_implicit_length.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/invalid_typedef.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/declarators/invalid_typedef.c:1:19: error: \u2018long long long\u2019 is too long for GCC\n typedef long long long lll;\n                   ^~~~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/invalid_Array_Pointer.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/declarators/invalid_Array_Pointer.c:1:5: error: size of array \u2018a\u2019 is negative\n int a[-1];\n     ^\ntypechecker/declarators/invalid_Array_Pointer.c:2:5: error: size of array \u2018b\u2019 is negative\n int b[1 - 2];\n     ^\ntypechecker/declarators/invalid_Array_Pointer.c:3:7: error: expected identifier or \u2018(\u2019 before \u2018)\u2019 token\n int (*)c;\n       ^\ntypechecker/declarators/invalid_Array_Pointer.c:4:7: error: expected identifier or \u2018(\u2019 before \u2018)\u2019 token\n int (*)(d);\n       ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/PASS_paren.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/declarators/PASS_valid_array_with_init.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/struct/tagged.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/struct/selfref.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/struct/nested_anonymous.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/struct/nested_anonymous.c: In function \u2018main\u2019:\ntypechecker/struct/nested_anonymous.c:19:12: error: variable \u2018data\u2019 has initializer but incomplete type\n     struct contents data = current->data;\n            ^~~~~~~~\ntypechecker/struct/nested_anonymous.c:19:21: error: storage size of \u2018data\u2019 isn\u2019t known\n     struct contents data = current->data;\n                     ^~~~\ntypechecker/struct/nested_anonymous.c:20:5: warning: implicit declaration of function \u2018printf\u2019 [-Wimplicit-function-declaration]\n     printf(\"data: %c\\n\", data.p);\n     ^~~~~~\ntypechecker/struct/nested_anonymous.c:20:5: warning: incompatible implicit declaration of built-in function \u2018printf\u2019\ntypechecker/struct/nested_anonymous.c:20:5: note: include \u2018<stdio.h>\u2019 or provide a declaration of \u2018printf\u2019\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/struct/redef.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"typechecker/struct/redef.c: In function \u2018main\u2019:\ntypechecker/struct/redef.c:19:5: warning: implicit declaration of function \u2018printf\u2019 [-Wimplicit-function-declaration]\n     printf(\"data: %c\\n\", current->data.p);\n     ^~~~~~\ntypechecker/struct/redef.c:19:5: warning: incompatible implicit declaration of built-in function \u2018printf\u2019\ntypechecker/struct/redef.c:19:5: note: include \u2018<stdio.h>\u2019 or provide a declaration of \u2018printf\u2019\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/struct/tagnamespace.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/struct/struct_init.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/struct/no_nested_redef.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/struct/no_nested_redef.c:3:10: error: nested redefinition of \u2018struct list\u2019\n   struct list { char data } nested;\n          ^~~~\ntypechecker/struct/no_nested_redef.c:3:27: warning: no semicolon at end of struct or union\n   struct list { char data } nested;\n                           ^\ntypechecker/struct/no_nested_redef.c: In function \u2018main\u2019:\ntypechecker/struct/no_nested_redef.c:11:7: error: \u2018struct list\u2019 has no member named \u2018next\u2019\n   head.next = &tail;\n       ^\ntypechecker/struct/no_nested_redef.c:13:7: error: \u2018struct list\u2019 has no member named \u2018next\u2019\n   tail.next = 0;\n       ^\ntypechecker/struct/no_nested_redef.c:17:5: warning: implicit declaration of function \u2018printf\u2019 [-Wimplicit-function-declaration]\n     printf(\"data: %d\\n\", current->data);\n     ^~~~~~\ntypechecker/struct/no_nested_redef.c:17:5: warning: incompatible implicit declaration of built-in function \u2018printf\u2019\ntypechecker/struct/no_nested_redef.c:17:5: note: include \u2018<stdio.h>\u2019 or provide a declaration of \u2018printf\u2019\ntypechecker/struct/no_nested_redef.c:18:22: error: \u2018struct list\u2019 has no member named \u2018next\u2019\n     current = current->next;\n                      ^~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/struct/struct_global_forward_reference.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/struct/struct_global_forward_reference.c:7:12: error: field \u2018y\u2019 has incomplete type\n   struct t y;\n            ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/struct/nested.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/struct/nested.c: In function \u2018main\u2019:\ntypechecker/struct/nested.c:11:13: error: incompatible types when assigning to type \u2018struct contents\u2019 from type \u2018int\u2019\n   head.data = 1;\n             ^\ntypechecker/struct/nested.c:13:13: error: incompatible types when assigning to type \u2018struct contents\u2019 from type \u2018int\u2019\n   tail.data = 2;\n             ^\ntypechecker/struct/nested.c:18:5: warning: implicit declaration of function \u2018printf\u2019 [-Wimplicit-function-declaration]\n     printf(\"data: %d\\n\", current->data);\n     ^~~~~~\ntypechecker/struct/nested.c:18:5: warning: incompatible implicit declaration of built-in function \u2018printf\u2019\ntypechecker/struct/nested.c:18:5: note: include \u2018<stdio.h>\u2019 or provide a declaration of \u2018printf\u2019\ntypechecker/struct/nested.c:18:20: warning: format \u2018%d\u2019 expects argument of type \u2018int\u2019, but argument 2 has type \u2018struct contents\u2019 [-Wformat=]\n     printf(\"data: %d\\n\", current->data);\n                   ~^     ~~~~~~~~~~~~~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/struct/anonymous.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/primitive_function2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/pointer_struct1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/pointer_struct1.c: In function \u2018main\u2019:\ntypechecker/compound/pointer_struct1.c:10:5: error: incompatible types when assigning to type \u2018struct <anonymous>\u2019 from type \u2018int *\u2019\n   x = &num;\n     ^\ntypechecker/compound/pointer_struct1.c:11:3: error: invalid type argument of unary \u2018*\u2019 (have \u2018struct <anonymous>\u2019)\n   *x;\n   ^~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/primitive_pointer1.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"typechecker/compound/primitive_pointer1.c: In function \u2018main\u2019:\ntypechecker/compound/primitive_pointer1.c:8:5: warning: assignment makes pointer from integer without a cast [-Wint-conversion]\n   x = 1;\n     ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/array_function1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/array_function1.c: In function \u2018main\u2019:\ntypechecker/compound/array_function1.c:10:4: error: subscripted value is neither array nor pointer nor vector\n   x[2];\n    ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/pointer_pointer2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/pointer_pointer1.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/pointer_struct2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/primitive_struct2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/primitive_array1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/primitive_array1.c: In function \u2018main\u2019:\ntypechecker/compound/primitive_array1.c:8:5: error: assignment to expression with array type\n   x = 1;\n     ^\ntypechecker/compound/primitive_array1.c:9:4: error: lvalue required as increment operand\n   x++;\n    ^~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/struct_function2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/struct_struct1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/struct_struct1.c: In function \u2018main\u2019:\ntypechecker/compound/struct_struct1.c:8:4: error: \u2018struct <anonymous>\u2019 has no member named \u2018a\u2019\n   x.a;\n    ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/pointer_function1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/pointer_function1.c: In function \u2018main\u2019:\ntypechecker/compound/pointer_function1.c:12:5: error: lvalue required as left operand of assignment\n   x = &num;\n     ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/struct_function1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/struct_function1.c: In function \u2018main\u2019:\ntypechecker/compound/struct_function1.c:10:4: error: request for member \u2018a\u2019 in something not a structure or union\n   x.a;\n    ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/primitive_array2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/struct_struct2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/array_struct1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/array_struct1.c: In function \u2018main\u2019:\ntypechecker/compound/array_struct1.c:8:4: error: subscripted value is neither array nor pointer nor vector\n   x[2];\n    ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/array_function2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/pointer_array1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/pointer_array1.c: In function \u2018main\u2019:\ntypechecker/compound/pointer_array1.c:10:5: error: assignment to expression with array type\n   x = &num;\n     ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/array_struct2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/array_array1.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/primitive_function1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/primitive_function1.c: In function \u2018main\u2019:\ntypechecker/compound/primitive_function1.c:10:4: error: lvalue required as increment operand\n   x++;\n    ^~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/primitive_pointer2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/function_function1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/function_function1.c: In function \u2018main\u2019:\ntypechecker/compound/function_function1.c:12:3: error: too many arguments to function \u2018x\u2019\n   x(3.2, 4.0);\n   ^\ntypechecker/compound/function_function1.c:6:6: note: declared here\n char x(int y) {\n      ^\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/primitive_primitive1.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/primitive_struct1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"typechecker/compound/primitive_struct1.c: In function \u2018main\u2019:\ntypechecker/compound/primitive_struct1.c:8:5: error: incompatible types when assigning to type \u2018struct <anonymous>\u2019 from type \u2018int\u2019\n   x = 1;\n     ^\ntypechecker/compound/primitive_struct1.c:9:4: error: wrong type argument to increment\n   x++;\n    ^~\n",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/function_function2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/pointer_function2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "typechecker/compound/pointer_array2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_local_illegal.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/struct_local_illegal.c: In function \u2018main\u2019:\nunit/struct_local_illegal.c:2:12: error: storage size of \u2018x\u2019 isn\u2019t known\n   struct s x;\n            ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/struct_nested.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/conditionalexpression.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/enum_size.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/enum_size.c: In function \u2018main\u2019:\nunit/enum_size.c:15:17: warning: format \u2018%llx\u2019 expects argument of type \u2018long long unsigned int\u2019, but argument 2 has type \u2018long int\u2019 [-Wformat=]\n   printf(\"%016llx\\n\", A);\n           ~~~~~~^\n           %016lx\nunit/enum_size.c:16:17: warning: format \u2018%llx\u2019 expects argument of type \u2018long long unsigned int\u2019, but argument 2 has type \u2018long int\u2019 [-Wformat=]\n   printf(\"%016llx\\n\", B);\n           ~~~~~~^\n           %016lx\nunit/enum_size.c:17:17: warning: format \u2018%llx\u2019 expects argument of type \u2018long long unsigned int\u2019, but argument 2 has type \u2018long int\u2019 [-Wformat=]\n   printf(\"%016llx\\n\", C);\n           ~~~~~~^\n           %016lx\nunit/enum_size.c:18:17: warning: format \u2018%llx\u2019 expects argument of type \u2018long long unsigned int\u2019, but argument 2 has type \u2018long int\u2019 [-Wformat=]\n   printf(\"%016llx\\n\", x);\n           ~~~~~~^\n           %016lx\nunit/enum_size.c:19:17: warning: format \u2018%llx\u2019 expects argument of type \u2018long long unsigned int\u2019, but argument 2 has type \u2018int\u2019 [-Wformat=]\n   printf(\"%016llx\\n\", y);\n           ~~~~~~^\n           %016x\nunit/enum_size.c:22:17: warning: format \u2018%llx\u2019 expects argument of type \u2018long long unsigned int\u2019, but argument 2 has type \u2018long int\u2019 [-Wformat=]\n   printf(\"%016llx\\n\", x);\n           ~~~~~~^\n           %016lx\nunit/enum_size.c: At top level:\nunit/enum_size.c:3:8: error: storage size of \u2018x\u2019 isn\u2019t known\n enum E x;\n        ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/function_parameters_empty.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/z3.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/z3.c: In function \u2018main\u2019:\nunit/z3.c:14:16: error: missing binary operator before token \"and\"\n #if defined(A) and defined(B)\n                ^~~\nunit/z3.c:16:18: error: missing binary operator before token \"or\"\n #elif defined(A) or !defined(A)\n                  ^~\n",
      "inclusions":[]
    }
  },
  {
    "unit/if_statement.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/sizeof.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[
        "stddef.h"
      ]
    }
  },
  {
    "unit/struct_local_legal.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/if_statement_configurable3.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/global_redeclarations.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/global_redeclarations.c:5:6: error: conflicting types for \u2018x\u2019\n char x;\n      ^\nunit/global_redeclarations.c:3:5: note: previous declaration of \u2018x\u2019 was here\n int x;\n     ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/struct_configurable_cross_and_forward_ref.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/variable_partially_defined.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/variable_partially_defined.c: In function \u2018main\u2019:\nunit/variable_partially_defined.c:12:3: error: \u2018a\u2019 undeclared (first use in this function)\n   a;\n   ^\nunit/variable_partially_defined.c:12:3: note: each undeclared identifier is reported only once for each function it appears in\n",
      "inclusions":[]
    }
  },
  {
    "unit/enum_constant_expression1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/enum_constant_expression1.c:8:12: error: enumerator value for \u2018A\u2019 is not an integer constant\n enum bob { A = y };\n            ^\nunit/enum_constant_expression1.c:5:10: error: storage size of \u2018x\u2019 isn\u2019t known\n enum bob x;\n          ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/enum_enumerators.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/typedefname_and_variable_declarations.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/typedefname_and_variable_declarations.c: In function \u2018main\u2019:\nunit/typedefname_and_variable_declarations.c:8:5: error: expected \u2018;\u2019 before \u2018a\u2019\n   a a;\n     ^\nunit/typedefname_and_variable_declarations.c: In function \u2018f\u2019:\nunit/typedefname_and_variable_declarations.c:12:11: error: expected \u2018=\u2019, \u2018,\u2019, \u2018;\u2019, \u2018asm\u2019 or \u2018__attribute__\u2019 before \u2018a\u2019\n   const a a;\n           ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/abstractpointerdeclarator.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_undef_cast.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/struct_undef_cast.c: In function \u2018main\u2019:\nunit/struct_undef_cast.c:9:11: error: \u2018x\u2019 has an incomplete type \u2018struct s1\u2019\n   return ((struct s2) x).data;\n           ^\nunit/struct_undef_cast.c: At top level:\nunit/struct_undef_cast.c:1:11: error: storage size of \u2018x\u2019 isn\u2019t known\n struct s1 x;\n           ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/parendeclarator.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/function_parameters.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_global_local.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/struct_global_local.c:26:5: error: redefinition of \u2018main\u2019\n int main() {\n     ^~~~\nunit/struct_global_local.c:5:5: note: previous definition of \u2018main\u2019 was here\n int main() {\n     ^~~~\n",
      "inclusions":[]
    }
  },
  {
    "unit/struct_crossref_global2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/enum_forward_ref.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/enum_forward_ref.c:3:10: error: storage size of \u2018x\u2019 isn\u2019t known\n enum bob x;\n          ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/qualifiedpointer.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_crossref_global.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/struct_crossref_global.c:3:13: error: field \u2018next\u2019 has incomplete type\n   struct s2 next;\n             ^~~~\n",
      "inclusions":[]
    }
  },
  {
    "unit/begin_decls.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[
        "sys/cdefs.h"
      ]
    }
  },
  {
    "unit/enum_repeated_enumerators.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/enum_repeated_enumerators.c:2:15: error: redeclaration of enumerator \u2018A\u2019\n         A, B, A,\n               ^\nunit/enum_repeated_enumerators.c:2:9: note: previous definition of \u2018A\u2019 was here\n         A, B, A,\n         ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/function_parameters_configurable.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/function_parameters_configurable.c:5:7: error: expected declaration specifiers or \u2018...\u2019 before \u2018)\u2019 token\n       ) {\n       ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/statement_configurable.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/typedefname_partially_defined.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/typedefname_partially_defined.c: In function \u2018main\u2019:\nunit/typedefname_partially_defined.c:12:9: error: unknown type name \u2018a\u2019\n   const a a;\n         ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/declarators.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"unit/declarators.c:6:5: warning: array \u2018x4a\u2019 assumed to have one element\n int x4a[];\n     ^~~\n",
      "inclusions":[]
    }
  },
  {
    "unit/struct_configurable_main.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_crossref_local.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/if_statement_configurable1.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/function_parameters_empty_configurable.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/redeclare_structs.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/redeclare_structs.c:7:8: error: redefinition of \u2018struct x\u2019\n struct x {\n        ^\nunit/redeclare_structs.c:1:8: note: originally defined here\n struct x {\n        ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/forloop.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_simple.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"unit/struct_simple.c:4:1: warning: unnamed struct/union that defines no instances\n };\n ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/struct_desugar_test.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_global_forward_reference_desugar.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_nested_anonymous.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/enum_constant_expression2.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/enum_constant_expression2.c:8:12: error: enumerator value for \u2018A\u2019 is not an integer constant\n enum bob { A = y + 2 };\n            ^\nunit/enum_constant_expression2.c:5:10: error: storage size of \u2018x\u2019 isn\u2019t known\n enum bob x;\n          ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/enum_configurable.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/enum_configurable.c:3:9: error: initializer element is not constant\n int x = p ? 1 : 0;\n         ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/if_statement_configurable2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/forloopdecl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_global_forward_reference.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/configurable_array.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/configurable_array.c:7:5: error: variably modified \u2018y\u2019 at file scope\n int y[][x];\n     ^\nunit/configurable_array.c:7:5: warning: array \u2018y\u2019 assumed to have one element\n",
      "inclusions":[]
    }
  },
  {
    "unit/enum_libbb.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_global_forward_reference_illegal.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/struct_global_forward_reference_illegal.c:3:12: error: field \u2018y\u2019 has incomplete type\n   struct t y;\n            ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/struct_multiply_defined_ifdeftoif.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/struct_multiply_defined_ifdeftoif.c:1:10: fatal error: /home/paul/src/typechef/ifdeftoif/id2i_optionstruct.h: No such file or directory\n #include \"/home/paul/src/typechef/ifdeftoif/id2i_optionstruct.h\"\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[]
    }
  },
  {
    "unit/struct_selfref_local.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_selfref.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/function_pointer.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_forward_scope.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/desugarer_test.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/enum_tag.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/enum_error.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/enum.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/initializers.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/initializers.c:2:11: warning: initialization makes pointer from integer without a cast [-Wint-conversion]\n int *x2 = 1;\n           ^\nunit/initializers.c:3:14: warning: initialization makes pointer from integer without a cast [-Wint-conversion]\n int *(x2b) = 1;\n              ^\nunit/initializers.c:4:12: warning: initialization makes pointer from integer without a cast [-Wint-conversion]\n int **x3 = 1;\n            ^\nunit/initializers.c:5:19: warning: initialization makes pointer from integer without a cast [-Wint-conversion]\n int (*(*(x3b))) = 1;\n                   ^\nunit/initializers.c:6:13: error: invalid initializer\n int x4a[] = 1;\n             ^\nunit/initializers.c:7:14: error: invalid initializer\n int x4b[2] = 1;\n              ^\nunit/initializers.c:8:16: error: invalid initializer\n int x5[3][3] = 1;\n                ^\nunit/initializers.c:9:14: error: invalid initializer\n int *x6[4] = 1;\n              ^\nunit/initializers.c:10:15: error: invalid initializer\n int **x7[6] = 1;\n               ^\nunit/initializers.c:11:16: warning: initialization makes pointer from integer without a cast [-Wint-conversion]\n int (*x8)[7] = 1;\n                ^\nunit/initializers.c:16:5: warning: built-in function \u2018y1\u2019 declared as non-function\n int y1, *y2, *(y2b), **y3, (*(*(y3b))), y4a[], y4b[2], y5[3][3], *y6[4], **y7[6], (*y8)[7];\n     ^~\nunit/initializers.c:16:41: warning: array \u2018y4a\u2019 assumed to have one element\n int y1, *y2, *(y2b), **y3, (*(*(y3b))), y4a[], y4b[2], y5[3][3], *y6[4], **y7[6], (*y8)[7];\n                                         ^~~\n",
      "inclusions":[]
    }
  },
  {
    "unit/designated_initializer.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/typedef_local_declaration.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_multiply_defined.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"unit/struct_multiply_defined.c:11:1: warning: unnamed struct/union that defines no instances\n };\n ^\n",
      "inclusions":[]
    }
  },
  {
    "unit/local_redeclarations.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/declaringlist.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"unit/declaringlist.c:1:41: warning: array \u2018x4a\u2019 assumed to have one element\n int x1, *x2, *(x2b), **x3, (*(*(x3b))), x4a[], x4b[2], x5[3][3], *x6[4], **x7[6], (*x8)[7];\n                                         ^~~\n",
      "inclusions":[]
    }
  },
  {
    "unit/struct_configurable_tls1.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/size_t.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[
        "stddef.h"
      ]
    }
  },
  {
    "unit/typedef.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/struct_global_forward_reference_ifdeftoif.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/struct_global_forward_reference_ifdeftoif.c:1:10: fatal error: /home/paul/src/typechef/ifdeftoif/id2i_optionstruct.h: No such file or directory\n #include \"/home/paul/src/typechef/ifdeftoif/id2i_optionstruct.h\"\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[]
    }
  },
  {
    "unit/struct_union_enum.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/struct_union_enum.c:4:19: error: field \u2018sa\u2019 has incomplete type\n   struct sockaddr sa;\n                   ^~\nunit/struct_union_enum.c:5:22: error: field \u2018sin\u2019 has incomplete type\n   struct sockaddr_in sin;\n                      ^~~\nunit/struct_union_enum.c: In function \u2018main\u2019:\nunit/struct_union_enum.c:13:3: error: request for member \u2018u\u2019 in something not a structure or union\n   __builtin_offsetof(int, u);\n   ^~~~~~~~~~~~~~~~~~\n",
      "inclusions":[]
    }
  },
  {
    "unit/jump_statement.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"unit/jump_statement.c: In function \u2018main\u2019:\nunit/jump_statement.c:3:3: error: continue statement not within a loop\n   continue;\n   ^~~~~~~~\nunit/jump_statement.c:4:3: error: break statement not within loop or switch\n   break;\n   ^~~~~\nunit/jump_statement.c:2:3: error: label \u2018label\u2019 used but not defined\n   goto label;\n   ^~~~\n",
      "inclusions":[]
    }
  },
  {
    "unit/single.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/switch.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[
        "stdio.h"
      ]
    }
  },
  {
    "unit/struct_configurable.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "unit/offsetof.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[
        "stddef.h"
      ]
    }
  },
  {
    "transformation/functions/main.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/function_declaration.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/function_call_non_void.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/config_identifier.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/config_return_type.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/int_main.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/void_main.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/config_implicit_function_call.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/function_pointer.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"transformation/functions/function_pointer.c: In function \u2018fun\u2019:\ntransformation/functions/function_pointer.c:5:5: warning: implicit declaration of function \u2018printf\u2019 [-Wimplicit-function-declaration]\n     printf(\"Value of a is %d\\n\", a);\n     ^~~~~~\ntransformation/functions/function_pointer.c:5:5: warning: incompatible implicit declaration of built-in function \u2018printf\u2019\ntransformation/functions/function_pointer.c:5:5: note: include \u2018<stdio.h>\u2019 or provide a declaration of \u2018printf\u2019\n",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/config_parameters.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/config_main_body.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/config_explicit_function_call.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/function_call_void.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/single.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/functions/config_multiply_defined_parameter.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/extern_var_multiply-defined_primitive.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/extern_var_multiply-defined_primitive.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/local_var_multiply-defined_primitive.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/local_var_multiply-defined_primitive.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/types_global_function_multiply-defined.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_global_function_multiply-defined.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/types_multiple_scopes.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_multiple_scopes.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/types_multiple_scopes.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/global_function_multiply-defined.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/global_function_multiply-defined.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/types_global_function_multiple_prototypes_same_body.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_global_function_multiple_prototypes_same_body.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/extern_function_multiply-defined.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/extern_function_multiply-defined.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/types_global_function_multiply-defined_pointer.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/extern_var_multiply-defined_primitive.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/types_primitive_and_compound.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_primitive_and_compound.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/types_extern_function_multiply-defined.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_extern_function_multiply-defined.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/types_global_function_multiply-defined.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_global_function_multiply-defined.c: In function \u2018main\u2019:\ntransformation/constructs/types_global_function_multiply-defined.c:16:3: error: too few arguments to function \u2018x\u2019\n   x();\n   ^\ntransformation/constructs/types_global_function_multiply-defined.c:7:6: note: declared here\n char x(int y) {\n      ^\n",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/types_primitive_and_compound.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_primitive_and_compound.c: In function \u2018main\u2019:\ntransformation/constructs/types_primitive_and_compound.c:13:6: error: request for member \u2018x\u2019 in something not a structure or union\n   var.x = 1;\n      ^\n",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/local_var_multiply-defined_primitive.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/global_function_multiple_prototypes_same_body.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/global_function_static.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/global_function_static.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/extern_function_multiply-defined.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/global_function_multiple_prototypes_same_body.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/global_function_multiple_prototypes_same_body.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/types_function_and_extern_primitive.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/static_function_multiple_prototypes_same_body.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/types_global_function_multiply-defined_pointer.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_global_function_multiply-defined_pointer.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/types_extern_var_partially-defined.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_extern_var_partially-defined.c: In function \u2018main\u2019:\ntransformation/constructs/types_extern_var_partially-defined.c:7:3: error: \u2018x\u2019 undeclared (first use in this function)\n   x++;\n   ^\ntransformation/constructs/types_extern_var_partially-defined.c:7:3: note: each undeclared identifier is reported only once for each function it appears in\n",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/global_var_static.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/global_var_static2.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"transformation/constructs/global_var_static2.c: In function \u2018main\u2019:\ntransformation/constructs/global_var_static2.c:12:3: warning: implicit declaration of function \u2018printf\u2019 [-Wimplicit-function-declaration]\n   printf(\"%x\\n\", y);\n   ^~~~~~\ntransformation/constructs/global_var_static2.c:12:3: warning: incompatible implicit declaration of built-in function \u2018printf\u2019\ntransformation/constructs/global_var_static2.c:12:3: note: include \u2018<stdio.h>\u2019 or provide a declaration of \u2018printf\u2019\n",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/types_global_function_multiple_prototypes_same_body.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_global_function_multiple_prototypes_same_body.c: In function \u2018x\u2019:\ntransformation/constructs/types_global_function_multiple_prototypes_same_body.c:14:11: error: \u2018y\u2019 undeclared (first use in this function)\n   b = b + y;\n           ^\ntransformation/constructs/types_global_function_multiple_prototypes_same_body.c:14:11: note: each undeclared identifier is reported only once for each function it appears in\n",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/global_function_static.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/global_var_static.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/global_var_static.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/constructs/global_function_multiply-defined.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/struct_multiply_defined.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/types_extern_function_multiply-defined.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_extern_function_multiply-defined.c: In function \u2018main\u2019:\ntransformation/constructs/types_extern_function_multiply-defined.c:8:3: error: too few arguments to function \u2018x\u2019\n   x();\n   ^\ntransformation/constructs/types_extern_function_multiply-defined.c:4:14: note: declared here\n extern float x(int);\n              ^\n",
      "inclusions":[]
    }
  },
  {
    "transformation/constructs/types_extern_var_partially-defined.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/constructs/types_extern_var_partially-defined.autodesugar.c:2:10: fatal error: desugared_macros.h: No such file or directory\n #include \"desugared_macros.h\" // configuration macros converted to C variables\n          ^~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdbool.h"
      ]
    }
  },
  {
    "transformation/declaringlists/main.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/all_init.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/no_init.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/config_some_init.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/config_no_init.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/error_conditional.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/declaringlists/error_conditional.c: In function \u2018main\u2019:\ntransformation/declaringlists/error_conditional.c:5:8: error: two or more data types in declaration specifiers\n   char char x;\n        ^~~~\n",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/variable_expr.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/config_const_conditional_error.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/declaringlists/config_const_conditional_error.c: In function \u2018main\u2019:\ntransformation/declaringlists/config_const_conditional_error.c:6:11: error: \u2018x\u2019 undeclared (first use in this function)\n   int y = x;\n           ^\ntransformation/declaringlists/config_const_conditional_error.c:6:11: note: each undeclared identifier is reported only once for each function it appears in\n",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/config_const.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/error_global.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/declaringlists/error_global.c:1:5: error: two or more data types in declaration specifiers\n int int j;\n     ^~~\n",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/one_init.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/some_init.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/undeclared.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/single.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/declaringlists/error.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/declaringlists/error.c:1:6: error: two or more data types in declaration specifiers\n char char x;\n      ^~~~\n",
      "inclusions":[]
    }
  },
  {
    "transformation/union/config_union_expressions.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/union/config_union_expressions.c: In function \u2018main\u2019:\ntransformation/union/config_union_expressions.c:17:12: error: \u2018union intCharFloat\u2019 has no member named \u2018character\u2019\n   usedUnion.character = 'h';\n            ^\ntransformation/union/config_union_expressions.c:23:36: error: \u2018union intCharFloat\u2019 has no member named \u2018character\u2019\n   y = usedUnion.integer + usedUnion.character;\n                                    ^\ntransformation/union/config_union_expressions.c:32:22: error: \u2018union intCharFloat\u2019 has no member named \u2018character\u2019\n   char ch = usedUnion.character;\n                      ^\n",
      "inclusions":[]
    }
  },
  {
    "transformation/union/union.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/union/union_use.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/union/config_partially_defined_fields2.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/union/config_partially_defined_fields2.c: In function \u2018main\u2019:\ntransformation/union/config_partially_defined_fields2.c:15:12: error: \u2018union intCharFloat\u2019 has no member named \u2018character\u2019\n   usedUnion.character = 'h';\n            ^\n",
      "inclusions":[]
    }
  },
  {
    "transformation/union/config_union_decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/union/config_partially_defined_fields1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/union/config_partially_defined_fields1.c: In function \u2018main\u2019:\ntransformation/union/config_partially_defined_fields1.c:18:12: error: \u2018union intCharFloat\u2019 has no member named \u2018character\u2019\n   usedUnion.character = 'h';\n            ^\n",
      "inclusions":[]
    }
  },
  {
    "transformation/union/config_partially_defined_union.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/union/config_partially_defined_union.c: In function \u2018main\u2019:\ntransformation/union/config_partially_defined_union.c:10:22: error: storage size of \u2018usedUnion\u2019 isn\u2019t known\n   union intCharFloat usedUnion;\n                      ^~~~~~~~~\n",
      "inclusions":[]
    }
  },
  {
    "transformation/enum/enum_typedef.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/enum/enum_decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/enum/config_enum.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/enum/config_enum.c: In function \u2018main\u2019:\ntransformation/enum/config_enum.c:13:15: error: storage size of \u2018apple\u2019 isn\u2019t known\n   enum letter apple;\n               ^~~~~\ntransformation/enum/config_enum.c:14:11: error: \u2018a\u2019 undeclared (first use in this function)\n   apple = a;\n           ^\ntransformation/enum/config_enum.c:14:11: note: each undeclared identifier is reported only once for each function it appears in\n",
      "inclusions":[]
    }
  },
  {
    "transformation/enum/config_enum_field.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/enum/config_enum_field.c: In function \u2018main\u2019:\ntransformation/enum/config_enum_field.c:9:15: error: storage size of \u2018apple\u2019 isn\u2019t known\n   enum letter apple;\n               ^~~~~\ntransformation/enum/config_enum_field.c:10:11: error: \u2018a\u2019 undeclared (first use in this function)\n   apple = a;\n           ^\ntransformation/enum/config_enum_field.c:10:11: note: each undeclared identifier is reported only once for each function it appears in\n",
      "inclusions":[]
    }
  },
  {
    "transformation/enum/enum.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/enum/config_typedef_enum.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/ifelsewhile/if_with_braces.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/ifelsewhile/while_with_braces.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/ifelsewhile/if_no_braces.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/ifelsewhile/do_while.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/ifelsewhile/if_else_with_braces.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/ifelsewhile/while_no_braces.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/ifelsewhile/explicit_config_if.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/ifelsewhile/if_else_no_braces.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/ifelsewhile/implicit_config_if.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/icse19nier/icsenier2.desugared1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/icse19nier/icsenier2.desugared1.c:1:1: error: unknown type name \u2018bool\u2019; did you mean \u2018_Bool\u2019?\n bool CONFIG_QUOTA; /* originally a macro */\n ^~~~\n _Bool\n",
      "inclusions":[]
    }
  },
  {
    "transformation/icse19nier/icsenier1.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/icse19nier/icsenier2.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/icse19nier/icsenier2.c: In function \u2018main\u2019:\ntransformation/icse19nier/icsenier2.c:10:6: error: \u2018struct t\u2019 has no member named \u2018i_reserved_quota\u2019\n   var.i_reserved_quota = 1;\n      ^\n",
      "inclusions":[]
    }
  },
  {
    "transformation/icse19nier/icsenier2.desugared2.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/icse19nier/icsenier2.desugared2.c:1:1: error: unknown type name \u2018bool\u2019; did you mean \u2018_Bool\u2019?\n bool CONFIG_QUOTA; /* originally a macro */\n ^~~~\n _Bool\n",
      "inclusions":[]
    }
  },
  {
    "transformation/icse19nier/icsenier3.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/typedef_struct/typedef_struct_no_main.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/typedef_struct/typedef_struct.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/typedef_struct/config_struct.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/typedef_struct/config_field_typedef.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/typedef_struct/config_typedef_struct_decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/typedef_struct/config_typedef_field.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/typedef_struct/config_partially_defined_struct_field.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/typedef_struct/config_partially_defined_struct_field.c:7:3: error: unknown type name \u2018typeAlias\u2019\n   typeAlias val;\n   ^~~~~~~~~\n",
      "inclusions":[]
    }
  },
  {
    "transformation/typedef_struct/config_typedef.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/typedef_struct/config_partially_defined_struct.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/typedef_struct/typedef_struct_decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/singlevariable.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/canonical.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/main.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/twovariables.autodesugar.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/misc/twovariables.autodesugar.c: In function \u2018main\u2019:\ntransformation/misc/twovariables.autodesugar.c:3:6: error: \u2018defined\u2019 undeclared (first use in this function)\n if ((defined CONFIG_B)) { /* from static conditional around function definition */\n      ^~~~~~~\ntransformation/misc/twovariables.autodesugar.c:3:6: note: each undeclared identifier is reported only once for each function it appears in\ntransformation/misc/twovariables.autodesugar.c:3:14: error: expected \u2018)\u2019 before \u2018CONFIG_B\u2019\n if ((defined CONFIG_B)) { /* from static conditional around function definition */\n              ^~~~~~~~\ntransformation/misc/twovariables.autodesugar.c:8:14: error: expected \u2018)\u2019 before \u2018CONFIG_B\u2019\n if ((defined CONFIG_B) && (defined CONFIG_C)) { /* from static conditional around statement */\n              ^~~~~~~~\ntransformation/misc/twovariables.autodesugar.c:8:36: error: expected \u2018)\u2019 before \u2018CONFIG_C\u2019\n if ((defined CONFIG_B) && (defined CONFIG_C)) { /* from static conditional around statement */\n                                    ^~~~~~~~\ntransformation/misc/twovariables.autodesugar.c:11:14: error: expected \u2018)\u2019 before \u2018CONFIG_B\u2019\n if ((defined CONFIG_B) && (defined CONFIG_A) && (defined CONFIG_C)) { /* from static conditional around statement */\n              ^~~~~~~~\ntransformation/misc/twovariables.autodesugar.c:11:36: error: expected \u2018)\u2019 before \u2018CONFIG_A\u2019\n if ((defined CONFIG_B) && (defined CONFIG_A) && (defined CONFIG_C)) { /* from static conditional around statement */\n                                    ^~~~~~~~\ntransformation/misc/twovariables.autodesugar.c:11:58: error: expected \u2018)\u2019 before \u2018CONFIG_C\u2019\n if ((defined CONFIG_B) && (defined CONFIG_A) && (defined CONFIG_C)) { /* from static conditional around statement */\n                                                          ^~~~~~~~\ntransformation/misc/twovariables.autodesugar.c:14:14: error: expected \u2018)\u2019 before \u2018CONFIG_B\u2019\n if ((defined CONFIG_B) && (defined CONFIG_A)) { /* from static conditional around statement */\n              ^~~~~~~~\ntransformation/misc/twovariables.autodesugar.c:14:36: error: expected \u2018)\u2019 before \u2018CONFIG_A\u2019\n if ((defined CONFIG_B) && (defined CONFIG_A)) { /* from static conditional around statement */\n                                    ^~~~~~~~\ntransformation/misc/twovariables.autodesugar.c:17:14: error: expected \u2018)\u2019 before \u2018CONFIG_B\u2019\n if ((defined CONFIG_B) && (defined CONFIG_A)) { /* from static conditional around statement */\n              ^~~~~~~~\ntransformation/misc/twovariables.autodesugar.c:17:36: error: expected \u2018)\u2019 before \u2018CONFIG_A\u2019\n if ((defined CONFIG_B) && (defined CONFIG_A)) { /* from static conditional around statement */\n                                    ^~~~~~~~\n",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/inside.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/twovariables.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/bob.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/canonical_example.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/twovariablesdifferent.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/test.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/type.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/misc/regular_conditional.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/variable_arithmetic_assignment.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/array_variable_decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_variable_arithmetic_assignment.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/minimal_global_car_decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/variable_address.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/arrays.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/array_decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_short_constant_arithmetic_ops.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_postfix.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/short_constant_arithmetic_ops.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/icr_decr.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/array_expr_decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/short_variable_arithmetic_ops.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_long_constant_arithmetic_ops.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/long_variable_arithmetic_ops.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/array_assignment.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_constant_arithmetic_assignment.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_short_variable_arithmetic_ops.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_array_decl.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_var_address.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"transformation/expressions/config_var_address.c: In function \u2018main\u2019:\ntransformation/expressions/config_var_address.c:8:7: warning: assignment makes pointer from integer without a cast [-Wint-conversion]\n     y = 3;\n       ^\n",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_prefix.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/expressions.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_long_variable_arithmetic_ops.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/prefix.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/constant_arithmetic_assignment.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/postfix.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/long_constant_arithmetic_ops.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/expressions/config_arr_assignment.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/basic_03_resugared.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/loop_01.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/call_01.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/basic_03.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/basic_04_resugared.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/basic_01.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/twovariables.desugared_resugared.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/recursion_01.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/basic_01_resugared.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/basic_02.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/loop_01_resugared.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/recursion_01_resugared.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/call_01_resugared.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/basic_02_resugared.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/linear_constant/basic_04.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/secure_memory/memory1.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/phasar/secure_memory/memory1.c:4:10: fatal error: openssl/crypto.h: No such file or directory\n #include <openssl/crypto.h>\n          ^~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdio.h",
        "stdlib.h",
        "openssl/crypto.h"
      ]
    }
  },
  {
    "transformation/phasar/secure_memory/memory1_resugared.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/phasar/secure_memory/memory1_resugared.c:4:10: fatal error: openssl/crypto.h: No such file or directory\n #include <openssl/crypto.h>\n          ^~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdio.h",
        "stdlib.h",
        "openssl/crypto.h"
      ]
    }
  },
  {
    "transformation/phasar/secure_memory/memory1_2.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/phasar/secure_memory/memory1_2.c:4:10: fatal error: openssl/crypto.h: No such file or directory\n #include <openssl/crypto.h>\n          ^~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdio.h",
        "stdlib.h",
        "openssl/crypto.h"
      ]
    }
  },
  {
    "transformation/phasar/secure_memory/memory1_resugared_decls_added.c":{
      "valid":true,
      "stdOut":"",
      "stdErr":"",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/secure_memory/memory1_2_resugared_decls_added.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/phasar/secure_memory/memory1_2_resugared_decls_added.c: In function \u2018main\u2019:\ntransformation/phasar/secure_memory/memory1_2_resugared_decls_added.c:33:17: error: \u2018buffer\u2019 undeclared (first use in this function)\n    OPENSSL_free(buffer);\n                 ^\ntransformation/phasar/secure_memory/memory1_2_resugared_decls_added.c:10:21: note: in definition of macro \u2018OPENSSL_free\u2019\n         CRYPTO_free(buffer, OPENSSL_FILE, OPENSSL_LINE)\n                     ^~~~~~\ntransformation/phasar/secure_memory/memory1_2_resugared_decls_added.c:33:17: note: each undeclared identifier is reported only once for each function it appears in\n    OPENSSL_free(buffer);\n                 ^\ntransformation/phasar/secure_memory/memory1_2_resugared_decls_added.c:10:21: note: in definition of macro \u2018OPENSSL_free\u2019\n         CRYPTO_free(buffer, OPENSSL_FILE, OPENSSL_LINE)\n                     ^~~~~~\n",
      "inclusions":[]
    }
  },
  {
    "transformation/phasar/secure_memory/memory1_2_resugared.c":{
      "valid":false,
      "stdOut":"",
      "stdErr":"transformation/phasar/secure_memory/memory1_2_resugared.c:4:10: fatal error: openssl/crypto.h: No such file or directory\n #include <openssl/crypto.h>\n          ^~~~~~~~~~~~~~~~~~\ncompilation terminated.\n",
      "inclusions":[
        "stdio.h",
        "stdlib.h",
        "openssl/crypto.h"
      ]
    }
  }
]